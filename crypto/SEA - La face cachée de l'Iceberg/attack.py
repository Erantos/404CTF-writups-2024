from pwn import *
from random import randint
from tqdm import tqdm
from Crypto.Util.number import long_to_bytes, bytes_to_long
from hashlib import shake_256

SBox1=[
	#  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15
	0x24,0xc1,0x38,0x30,0xe7,0x57,0xdf,0x20,0x3e,0x99,0x1a,0x34,0xca,0xd6,0x52,0xfd, # Identical
	0x40,0x6c,0xd3,0x95,0x4a,0x59,0xf8,0x77,0x79,0x61,0x0a,0x56,0xb9,0xd2,0xfc,0xf1, # Differences at: 3, 8
	0x07,0xf5,0x93,0xcd,0x00,0xb6,0xcb,0xa7,0x63,0x98,0x44,0xbd,0x5f,0x92,0x6b,0x73, # Differences at: 6, 9, 15
	0x3c,0x4e,0xa2,0x97,0x0b,0x01,0x83,0xa3,0xee,0xe5,0x45,0x67,0xf4,0x13,0xad,0x8b, # Differences at: 0, 5, 8, 14
	0xbb,0x0c,0x72,0xb4,0x2a,0x3a,0xc5,0x84,0xec,0x9f,0x14,0xc0,0xc4,0x16,0x31,0xd9, # Differences at: 0, 1, 2, 6, 8, 14, 
	0xab,0x9e,0x0e,0x1d,0x7c,0x48,0x1b,0x05,0x1c,0xea,0xa5,0xf0,0x8f,0x85,0x50,0x2c,
	0x35,0xbf,0x26,0x28,0x7b,0xe2,0xaa,0xf9,0x4f,0xe3,0xcc,0x2e,0x11,0x76,0xb1,0x8d,
	0xd4,0x5e,0xaf,0xe8,0x42,0xb0,0x6d,0x65,0x82,0x6a,0x58,0x8a,0xdd,0x7e,0x22,0xd8,
	0xe0,0x4c,0x2d,0xcf,0x75,0x12,0x8e,0xb2,0xbc,0x36,0x2b,0x25,0xe1,0x78,0xfa,0xa9,
	0x69,0x81,0x89,0x5b,0x7d,0xde,0xdb,0x21,0x5d,0xd7,0xeb,0xac,0xb3,0x41,0x66,0x6e,
	0x9c,0xef,0xc3,0x17,0x15,0xc7,0xda,0x32,0x0f,0xb8,0xb7,0x71,0x39,0x29,0x87,0xc6,
	0xe9,0x1f,0xf3,0xa6,0x86,0x8c,0x2f,0x53,0x9d,0xa8,0x1e,0x0d,0x4b,0x7f,0x06,0x18,
	0x9b,0x60,0xbe,0x47,0x91,0x5c,0x70,0x68,0xf6,0x04,0xce,0x90,0xb5,0x03,0xa4,0xc8,
	0xe6,0xed,0x64,0x46,0x10,0xf7,0x88,0xae,0x4d,0x3f,0x94,0xa1,0x02,0x08,0xa0,0x80,
	0x9a,0x3d,0x37,0x19,0xd5,0xc9,0xfe,0x51,0xc2,0x27,0x33,0x3b,0x54,0xe4,0x23,0xdc,
	0x62,0x7a,0x55,0x09,0xd1,0xba,0xf2,0xff,0x6f,0x43,0x96,0xd0,0x5a,0x49,0x74,0xfb, # Differences everywhere
]

# Differential : 233->3 pour SBox1

SBox2=[
	0x24,0xc1,0x38,0x30,0xe7,0x57,0xdf,0x20,0x3e,0x99,0x1a,0x34,0xca,0xd6,0x52,0xfd,
	0x40,0x6c,0xd3,0x3d,0x4a,0x59,0xf8,0x77,0xfb,0x61,0x0a,0x56,0xb9,0xd2,0xfc,0xf1,
	0x07,0xf5,0x93,0xcd,0x00,0xb6,0x62,0xa7,0x63,0xfe,0x44,0xbd,0x5f,0x92,0x6b,0x68,
	0x03,0x4e,0xa2,0x97,0x0b,0x60,0x83,0xa3,0x02,0xe5,0x45,0x67,0xf4,0x13,0x08,0x8b,
	0x10,0xce,0xbe,0xb4,0x2a,0x3a,0x96,0x84,0xc8,0x9f,0x14,0xc0,0xc4,0x6f,0x31,0xd9,
	0xab,0xae,0x0e,0x64,0x7c,0xda,0x1b,0x05,0xa8,0x15,0xa5,0x90,0x94,0x85,0x71,0x2c,
	0x35,0x19,0x26,0x28,0x53,0xe2,0x7f,0x3b,0x2f,0xa9,0xcc,0x2e,0x11,0x76,0xed,0x4d,
	0x87,0x5e,0xc2,0xc7,0x80,0xb0,0x6d,0x17,0xb2,0xff,0xe4,0xb7,0x54,0x9d,0xb8,0x66,
	0x74,0x9c,0xdb,0x36,0x47,0x5d,0xde,0x70,0xd5,0x91,0xaa,0x3f,0xc9,0xd8,0xf3,0xf2,
	0x5b,0x89,0x2d,0x22,0x5c,0xe1,0x46,0x33,0xe6,0x09,0xbc,0xe8,0x81,0x7d,0xe9,0x49,
	0xe0,0xb1,0x32,0x37,0xea,0x5a,0xf6,0x27,0x58,0x69,0x8a,0x50,0xba,0xdd,0x51,0xf9,
	0x75,0xa1,0x78,0xd0,0x43,0xf7,0x25,0x7b,0x7e,0x1c,0xac,0xd4,0x9a,0x2b,0x42,0xe3,
	0x4b,0x01,0x72,0xd7,0x4c,0xfa,0xeb,0x73,0x48,0x8c,0x0c,0xf0,0x6a,0x23,0x41,0xec,
	0xb3,0xef,0x1d,0x12,0xbb,0x88,0x0d,0xc3,0x8d,0x4f,0x55,0x82,0xee,0xad,0x86,0x06,
	0xa0,0x95,0x65,0xbf,0x7a,0x39,0x98,0x04,0x9b,0x9e,0xa4,0xc6,0xcf,0x6e,0xdc,0xd1,
	0xcb,0x1f,0x8f,0x8e,0x3c,0x21,0xa6,0xb5,0x16,0xaf,0xc5,0x18,0x1e,0x0f,0x29,0x79,
]

def f(block):
    b1 = (block>>56)
    b2 = (block>>48) & 0xff
    b3 = (block>>40) & 0xff
    b4 = (block>>32) & 0xff
    b5 = (block>>24) & 0xff
    b6 = (block>>16) & 0xff
    b7 = (block>>8) & 0xff
    b8 = block & 0xff

    b2 ^= b3
    b1 ^= b2
    b1 = SBox1[b1]
    b2 ^= b1
    b2 = SBox2[b2]
    b3 ^= b2
    b3 = SBox2[b3]
    b3 ^= b1
    b4 ^= b5
    b4 = SBox2[b4]
    b5 ^= b4
    b5 = SBox1[b5]
    b7 ^= b6
    b6 = SBox1[b6]
    b7^= b6
    b7 = SBox2[b7]
    b8 ^= b7
    b6 ^= b7
    b8 = SBox1[b8]

    return (b2<<56)+(b3<<48)+(b6<<40)+(b1<<32)+(b4<<24)+(b8<<16)+(b5<<8)+b7

context.log_level = "debug"

def hexStr(n, length):
    s = hex(n)[2:]
    pad = length - len(s) if len(s) < length else 0
    return pad*'0' + hex(n)[2:]

def splitLR(n):
    return n >> 64, n & 0xffffffffffffffff

def checkMatch(l1, l2, mask):
    return l1 & mask == l2 & mask

def genNumber(delta):
    a = randint(0,2**128) # 16 random bytes
    b = a ^ delta
    return a, b

def reduceKeyCandidates(ca_l, cb_l, d1, full_run, prev_cand):
    new_cand = [[], [], []]
    masks = [0xffff00ff00000000, 0x00000000ff00ff00, 0x0000ff0000ff00ff]
    if full_run or len(prev_cand) == 0:
        for i in tqdm(range(2**24)):
            key = (i << 40) + ((i % (2**16)) << 24) + i
            d1_guess = f(ca_l ^ key) ^ f(cb_l ^ key)
            if checkMatch(d1_guess, d1, masks[0]):
                new_cand[0].append(i)
            if checkMatch(d1_guess, d1, masks[1]) and (i < 2**16):
                new_cand[1].append(i)
            if checkMatch(d1_guess, d1, masks[2]):
                new_cand[2].append(i)
    else:
        for i in range(3):
            offset = [40, 24, 0]
            for ks in prev_cand[i]:
                key = ks << offset[i]
                d1_guess = f(ca_l ^ key) ^ f(cb_l ^ key)
                if checkMatch(d1_guess, d1, masks[i]):
                    new_cand[i].append(ks)
    return new_cand

def get_keys(cands):
    keys = []
    for i in cands[0]:
        for j in cands[1]:
            for k in cands[2]:
                keys.append((i << 40) + (j << 24) + k)
    return keys

def waitNext():
    return r.recvuntil(b"please) > ").decode()

def getCiphers(payload):
    res = []
    for j in range(2):
        a, b = genNumber(payload)
        # Cipher random a and b separated by delta
        r.sendline(hexStr(a, 32).encode())
        # for k in range(4):
        #     r.recvline()

        ca = int(r.recvline().decode(), 16)
        waitNext()

        r.sendline(hexStr(b, 32).encode())
        # for k in range(4):
        #     r.recvline()
        cb = int(r.recvline().decode(), 16)
        waitNext()
        res.append(((a, ca), (b, cb)))
    return res

def undoRound(c, k):
    l, r = splitLR(c)
    out = f(l ^ k)
    tmp_l = l
    l = out ^ r
    r = tmp_l
    return (l << 64) + r

###
# MAIN
###

# Constants
CIPHER = None
KNOWN_DELTA_0 = 0xea0300e9e9e9eae9 # Precomputed from code analysis
KNOWN_DELTA_1 = 0x0003030300030300 # D0 after passing through f

PAYLOAD = {
    4: KNOWN_DELTA_0 << 64,
    3: KNOWN_DELTA_0,
    2: KNOWN_DELTA_1,
    1: 0x0101010101010101
}

# r = process(['python', 'sea.py'])
r = remote('challenges.404ctf.fr', 31951)

data = waitNext()

# Get final cipher text
for l in data.split('\n'):
    if "encrypted secret" in l:
        CIPHER = bytes.fromhex(l.split(' : ')[1])

k4_cand = None
ciph4 = getCiphers(PAYLOAD[4])
ciph3 = getCiphers(PAYLOAD[3])
ciph2 = getCiphers(PAYLOAD[2])
ciph1 = getCiphers(PAYLOAD[1])

r.recvall(timeout=2)
r.close()

for i in range(2):
    ca, cb = ciph4[i][0][1], ciph4[i][1][1]

    # Get K4 from the result
    df = ca ^ cb
    dl,dr = splitLR(df)
    ca_l, ca_r = splitLR(ca)
    cb_l, cb_r = splitLR(cb)
    d1 = dr ^ KNOWN_DELTA_1

    # 3 steps check for key 4
    print("start k4 guess")
    k4_cand = reduceKeyCandidates(ca_l, cb_l, d1, i==0, k4_cand)

key4cand = get_keys(k4_cand)
   
# Get key 3 and 4 using hash condition
k3_cand_all = []
real_k4 = None
real_k3 = None

ca, cb = ciph3[1][0][1], ciph3[1][1][1]

for k4 in key4cand:
    k3_cand = None
    isFound = False
    for j in range(2):
        ca, cb = ciph3[j][0][1], ciph3[j][1][1]

        # Undo one round to guess K3
        ca = undoRound(ca, k4)
        cb = undoRound(cb, k4)

        # Get K3 from the result
        df = ca ^ cb
        dl,dr = splitLR(df)
        ca_l, ca_r = splitLR(ca)
        cb_l, cb_r = splitLR(cb)
        d1 = dr ^ KNOWN_DELTA_1

        # 3 steps check for key 3
        print("start k3 guess")
        k3_cand = reduceKeyCandidates(ca_l, cb_l, d1, j==0, k3_cand)
    
    key3cand = get_keys(k3_cand)
    for k3 in key3cand:
        hash = shake_256(long_to_bytes(k3)).digest(length=8)
        if hash == long_to_bytes(k4):
            isFound = True
            real_k4 = k4
            real_k3 = k3
            break
    if isFound:
        break

# Get key 2
k2_cand = None
for j in range(2):
    ca, cb = ciph2[j][0][1], ciph2[j][1][1]

    # Undo one round to guess K3
    ca = undoRound(ca, real_k4)
    ca = undoRound(ca, real_k3)
    cb = undoRound(cb, real_k4)
    cb = undoRound(cb, real_k3)

    # Get K2 from the result
    df = ca ^ cb
    dl,dr = splitLR(df)
    ca_l, ca_r = splitLR(ca)
    cb_l, cb_r = splitLR(cb)
    d1 = dr ^ KNOWN_DELTA_1

    # 3 steps check for key 2
    print("start k2 guess")
    k2_cand = reduceKeyCandidates(ca_l, cb_l, d1, j==0, k2_cand)

key2cand = get_keys(k2_cand)
for k2 in key2cand:
    hash = shake_256(long_to_bytes(k2)).digest(length=8)
    if hash == long_to_bytes(real_k3):
        real_k2 = k2
        break

# Get key 1 and 0
k1_cand = None
for j in range(2):
    ca, cb = ciph1[j][0][1], ciph1[j][1][1]

    # Undo one round to guess K3
    ca = undoRound(ca, real_k4)
    ca = undoRound(ca, real_k3)
    ca = undoRound(ca, real_k2)
    cb = undoRound(cb, real_k4)
    cb = undoRound(cb, real_k3)
    cb = undoRound(cb, real_k2)

    # Get K1 from the result
    df = ca ^ cb
    dl,dr = splitLR(df)
    ca_l, ca_r = splitLR(ca)
    cb_l, cb_r = splitLR(cb)
    d1 = dr ^ 0

    # 3 steps check for key 1
    print("start k1 guess")
    k1_cand = reduceKeyCandidates(ca_l, cb_l, d1, j==0, k1_cand)
    print(len(k1_cand[0]))
    print(len(k1_cand[1]))
    print(len(k1_cand[2]))

key1cand = get_keys(k1_cand)
for k1 in key1cand:
    hash = shake_256(long_to_bytes(k1)).digest(length=8)
    if hash == long_to_bytes(real_k2):
        real_k1 = k1
        break

a, ca = ciph1[0][0][0], ciph1[0][0][1]
ca = undoRound(ca, real_k4)
ca = undoRound(ca, real_k3)
ca = undoRound(ca, real_k2)
ca = undoRound(ca, real_k1)
real_k0 = ca ^ a

print(real_k0, real_k1, real_k2, real_k3, real_k4)

print(CIPHER)

c1, c2,c3, c4 = bytes_to_long(CIPHER[:16]), bytes_to_long(CIPHER[16:32]), bytes_to_long(CIPHER[32:48]), bytes_to_long(CIPHER[48:])

def decrypt(cipher):
	CIPHER = undoRound(cipher, real_k4)
	CIPHER = undoRound(CIPHER, real_k3)
	CIPHER = undoRound(CIPHER, real_k2)
	CIPHER = undoRound(CIPHER, real_k1)
	FLAG = CIPHER ^ real_k0
	return long_to_bytes(FLAG).decode()

print(decrypt(c1)+decrypt(c2)+decrypt(c3)+decrypt(c4))